library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
library(FDASCC)
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
setwd("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py")
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
library(gtools)
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
#' @import gtools
#' @importFrom gtools combinations
#'
cov1g.sce = function(n, N, kappa, Y, muhat, Ghat, GhatY, lamdaK, boot, alpha.grid = c(0.1, 0.05, 0.01)){
#Counstruct simultaneous confidnece envelope for the covariance funciton in one sample case
NN = 200  #test points
nalpha = length(alpha.grid)
Xi <- rep(0,boot)
##eigenfunctions
phi <- matrix((eigen(Ghat/N, symmetric=T)$vectors[,1:kappa])*sqrt(N),N,kappa)
phiY <- matrix((eigen(GhatY/NN, symmetric=T)$vectors[,1:kappa])*sqrt(NN),NN,kappa)
##get Vhat
epi <- ((Y-matrix(rep(muhat,n),n,N,byrow=T))%*%sweep(phi,2,(lamdaK)^(-0.5),'*')*N^(-1))^4
V.hat <- GhatY^2+diag(GhatY)%*%t(diag(GhatY))+(sweep(phiY^2, MARGIN=2, lamdaK, '*'))%*%t(sweep(sweep(phiY^2, MARGIN=2, lamdaK, '*'), MARGIN=2, (colMeans(epi)-3),'*'))
### obtain qunatile: resampling ####
com <- combinations(kappa,2,seq(1:kappa))
comb <- dim(com)[1]
Z2 <- matrix(rnorm(kappa*(kappa-1)/2*boot,0,1),boot,kappa*(kappa-1)/2)
Z1 <- matrix(rnorm(kappa*boot,0,1),boot,kappa)
for(b in 1:boot){
zeta <- 0
for(i in 1:comb){
zeta <- zeta+((phiY[,(com[i,1])]*lamdaK[(com[i,1])]^0.5)%*%t(phiY[,(com[i,2])]*lamdaK[(com[i,2])]^0.5)+
(phiY[,(com[i,2])]*lamdaK[(com[i,2])]^0.5)%*%t(phiY[,(com[i,1])]*lamdaK[(com[i,1])]^0.5))*Z2[b,(com[i,1])]
}
for(i in 1:kappa) {
zeta <- zeta+(phiY[,i]*lamdaK[i]^0.5)%*%t(phiY[,i]*lamdaK[i]^0.5)*((colMeans(epi)[i]-1))^0.5*Z1[b,i]
}
Xi[b] <- max(abs(zeta*(V.hat)^(-0.5)))
}
Q <- quantile(Xi,1-alpha.grid)#quantiles for three levels
###   construct the envelope     ###
####################################
sce.band <- array(NA,dim=c(NN,NN,2,nalpha))
for(j in 1:nalpha){
sce.band[,,1,j] <- GhatY-Q[j]*n^(-1/2)*(V.hat)^0.5#lower bound
sce.band[,,2,j] <- GhatY+Q[j]*n^(-1/2)*(V.hat)^0.5#upper bound
}
list(sce = sce.band)
}
#' @import gtools
#' @importFrom gtools combinations
#'
cov2g.sce = function(na, nb, N, kappa.a, kappa.b, Ya, Yb, muhat.a, muhat.b, Ghat.a, Ghat.b,  GhatY.a, GhatY.b, lamdaK.a, lamdaK.b, rab, boot, alpha.grid = c(0.1, 0.05, 0.01)){
#Counstruct simultaneous confidnece envelope for the difference of two covariance funcitons
NN = 200  #test points
nalpha = length(alpha.grid)
Xi <- rep(0,boot)
##eigenfunctions
##group1
phi.a <- matrix((eigen(Ghat.a/N, symmetric=T)$vectors[,1:kappa.a])*sqrt(N),N,kappa.a)
phiY.a <- matrix((eigen(GhatY.a/NN, symmetric=T)$vectors[,1:kappa.a])*sqrt(NN),NN,kappa.a)
##group2
phi.b <- matrix((eigen(Ghat.b/N, symmetric=T)$vectors[,1:kappa.b])*sqrt(N),N,kappa.b)
phiY.b <- matrix((eigen(GhatY.b/NN, symmetric=T)$vectors[,1:kappa.b])*sqrt(NN),NN,kappa.b)
##get Vhat
##group1
epi.a <- ((Ya-matrix(rep(muhat.a,na),na,N,byrow=T))%*%sweep(phi.a,2,(lamdaK.a)^(-0.5),'*')*N^(-1))^4
V.hat.a <- GhatY.a^2+diag(GhatY.a)%*%t(diag(GhatY.a))+(sweep(phiY.a^2, MARGIN=2, lamdaK.a, '*'))%*%t(sweep(sweep(phiY.a^2, MARGIN=2, lamdaK.a, '*'), MARGIN=2, (colMeans(epi.a)-3),'*'))
##group2
epi.b <- ((Yb-matrix(rep(muhat.b,nb),nb,N,byrow=T))%*%sweep(phi.b,2,(lamdaK.b)^(-0.5),'*')*N^(-1))^4
V.hat.b <- GhatY.b^2+diag(GhatY.b)%*%t(diag(GhatY.b))+(sweep(phiY.b^2, MARGIN=2, lamdaK.b, '*'))%*%t(sweep(sweep(phiY.b^2, MARGIN=2, lamdaK.b, '*'), MARGIN=2, (colMeans(epi.b)-3),'*'))
### obtain qunatile: resampling ####
com.a <- combinations(kappa.a,2,seq(1:kappa.a))
com.b <- combinations(kappa.b,2,seq(1:kappa.b))
comb.a <- dim(com.a)[1]
comb.b <- dim(com.b)[1]
Z2.a <- matrix(rnorm(kappa.a*(kappa.a-1)/2*boot,0,1),boot,kappa.a*(kappa.a-1)/2)
Z2.b <- matrix(rnorm(kappa.b*(kappa.b-1)/2*boot,0,1),boot,kappa.b*(kappa.b-1)/2)
Z1.a <- matrix(rnorm(kappa.a*boot,0,1),boot,kappa.a)
Z1.b <- matrix(rnorm(kappa.b*boot,0,1),boot,kappa.b)
for(b in 1:boot){
zeta.a <- 0
zeta.b <- 0
for(i in 1:comb.a){
zeta.a <- zeta.a+((phiY.a[,(com.a[i,1])]*lamdaK.a[(com.a[i,1])]^0.5)%*%t(phiY.a[,(com.a[i,2])]*lamdaK.a[(com.a[i,2])]^0.5)+
(phiY.a[,(com.a[i,2])]*lamdaK.a[(com.a[i,2])]^0.5)%*%t(phiY.a[,(com.a[i,1])]*lamdaK.a[(com.a[i,1])]^0.5))*Z2.a[b,(com.a[i,1])]
}
for(i in 1:comb.b){
zeta.b <- zeta.b+((phiY.b[,(com.b[i,1])]*lamdaK.b[(com.b[i,1])]^0.5)%*%t(phiY.b[,(com.b[i,2])]*lamdaK.b[(com.b[i,2])]^0.5)+
(phiY.b[,(com.b[i,2])]*lamdaK.b[(com.b[i,2])]^0.5)%*%t(phiY.b[,(com.b[i,1])]*lamdaK.b[(com.b[i,1])]^0.5))*Z2.b[b,(com.b[i,1])]
}
for(i in 1:kappa.a){
zeta.a <- zeta.a+(phiY.a[,i]*lamdaK.a[i]^0.5)%*%t(phiY.a[,i]*lamdaK.a[i]^0.5)*((colMeans(epi.a)[i]-1))^0.5*Z1.a[b,i]
}
for(i in 1:kappa.b){
zeta.b <- zeta.b+(phiY.b[,i]*lamdaK.b[i]^0.5)%*%t(phiY.b[,i]*lamdaK.b[i]^0.5)*((colMeans(epi.b)[i]-1))^0.5*Z1.b[b,i]
}
Xi[b] <= max(abs(zeta.a-zeta.b)*(V.hat.a - rab*V.hat.b)^(-0.5))
}
Q <- quantile(Xi,1-alpha.grid)#quantiles for three levels
###   construct the envelope     ###
####################################
sce.band <- array(NA,dim=c(NN, NN,2,nalpha))
for(j in 1:nalpha){
sce.band[,,1,j] <- GhatY.a-GhatY.b-Q[j]*na^(-0.5)*(V.hat.a+rab*V.hat.b)^0.5#lower bound
sce.band[,,2,j] <- GhatY.a-GhatY.b+Q[j]*na^(-0.5)*(V.hat.a+rab*V.hat.b)^0.5#upper bound
}
list(sce = sce.band)
}
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
install.packages("C:/Users/alley/Desktop/folders/courses-and-certifications/phd-cs/research/1d_fda/FDASCC_py/FDASCC/FDASCC", repos = NULL, type="source")
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
Yband.true <- 5*X.band + 4*sin(2*pi*(X.band-0.5))
Yband.v.true <- 5 + 8*pi*cos(2*pi*(X.band - 0.5))
plot(X, out$Yhat, type = 'l',
ylim = c(min(out$scc[,1,2])-1,max(out$scc[,2,2])+1))
lines(X.band, Yband.true, col = 2)
lines(X.band, out$scc[,1,2], col='blue')
lines(X.band, out$scc[,2,2], col='blue')
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
## Example 2: One Sample Case for functional mean (Cao, Yang, Todem, 2012. Simulation Studies)
n <- 100
N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(0.01, 1, 0.01)
mu1.true <- 10 + sin(2*pi*(X-1/2))
psi1 <- -sqrt(2)*cos(pi*(X-1/2))
psi2 <- sqrt(2)*sin(pi*(X-1/2))
lam1 <- 2
lam2 <- 0.5
sig <- 0.3  # sig <- 0.5
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
Y <- matrix(0,n,N)
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu1.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
lines(X.band, out$scc[,2,2], col='blue')
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
######################################################################
## Example 3: Two Sample Case for functional mean (Cao, Yang, Todem, 2012. Simulation Studies)
na <- 80
nb <- 160
N <- 100
X <- seq(1/N,1,1/N)
X.band <- seq(0.01, 1, 0.01)
mu1.true <- 10 + sin(2*pi*(X-1/2))
diff.mu <- 0.6 * X
# diff.mu <- 0.7 * sin(X)
# diff.mu <- 0
mu2.true <- mu1.true + diff.mu
psi1 <- -sqrt(2)*cos(pi*(X-1/2))
psi2 <- sqrt(2)*sin(pi*(X-1/2))
lam1 <- 2
lam2 <- 0.5
sig <- 0.3  # sig <- 0.5
xi1.all <- list(rnorm(na,mean=0,sd=sqrt(lam1)),
rnorm(nb,mean=0,sd=sqrt(lam1)))
xi2.all <- list(rnorm(na,mean=0,sd=sqrt(lam2)),
rnorm(nb,mean=0,sd=sqrt(lam2)))
Ya <- matrix(0,na,N)
Yb <- matrix(0,nb,N)
for(i in 1:na){
xi1 <- xi1.all[[1]]
xi2 <- xi2.all[[1]]
Ya[i,] <- mu1.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
for(i in 1:nb){
xi1 <- xi1.all[[2]]
xi2 <- xi2.all[[2]]
Yb[i,] <- mu2.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
out <- scc.1D(Ya, Yb, X, X.band)
plot(out)
# plot(X.band, Yband.v.true, type = 'l',
#      ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
# lines(X.band, out$scc.deriv[,1,2], col='blue')
# lines(X.band, out$scc.deriv[,2,2], col='blue')
#
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
lines(X.band, out$scc[,1,2], col='blue')
lines(X.band, out$scc[,2,2], col='blue')
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
## Example 2: One Sample Case for functional mean (Cao, Yang, Todem, 2012. Simulation Studies)
n <- 100
N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(0.01, 1, 0.01)
mu1.true <- 10 + sin(2*pi*(X-1/2))
psi1 <- -sqrt(2)*cos(pi*(X-1/2))
psi2 <- sqrt(2)*sin(pi*(X-1/2))
lam1 <- 2
lam2 <- 0.5
sig <- 0.3  # sig <- 0.5
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
Y <- matrix(0,n,N)
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu1.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
lines(X.band, out$scc[,2,2], col='blue')
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
######################################################################
## Example 3: Two Sample Case for functional mean (Cao, Yang, Todem, 2012. Simulation Studies)
na <- 80
nb <- 160
N <- 100
X <- seq(1/N,1,1/N)
X.band <- seq(0.01, 1, 0.01)
mu1.true <- 10 + sin(2*pi*(X-1/2))
diff.mu <- 0.6 * X
# diff.mu <- 0.7 * sin(X)
# diff.mu <- 0
mu2.true <- mu1.true + diff.mu
psi1 <- -sqrt(2)*cos(pi*(X-1/2))
psi2 <- sqrt(2)*sin(pi*(X-1/2))
lam1 <- 2
lam2 <- 0.5
sig <- 0.3  # sig <- 0.5
xi1.all <- list(rnorm(na,mean=0,sd=sqrt(lam1)),
rnorm(nb,mean=0,sd=sqrt(lam1)))
xi2.all <- list(rnorm(na,mean=0,sd=sqrt(lam2)),
rnorm(nb,mean=0,sd=sqrt(lam2)))
Ya <- matrix(0,na,N)
Yb <- matrix(0,nb,N)
for(i in 1:na){
xi1 <- xi1.all[[1]]
xi2 <- xi2.all[[1]]
Ya[i,] <- mu1.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
for(i in 1:nb){
xi1 <- xi1.all[[2]]
xi2 <- xi2.all[[2]]
Yb[i,] <- mu2.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
out <- scc.1D(Ya, Yb, X, X.band)
plot(out)
# plot(X.band, Yband.v.true, type = 'l',
#      ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
# lines(X.band, out$scc.deriv[,1,2], col='blue')
# lines(X.band, out$scc.deriv[,2,2], col='blue')
#
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
Yband.v.true <- 5 + 8*pi*cos(2*pi*(X.band - 0.5))
plot(X, out$Yhat, type = 'l',
ylim = c(min(out$scc[,1,2])-1,max(out$scc[,2,2])+1))
lines(X.band, Yband.true, col = 2)
lines(X.band, out$scc[,1,2], col='blue')
lines(X.band, out$scc[,2,2], col='blue')
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
View(out)
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
# matrix(colMeans(YY),N,1)->Y
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
Yband.true <- 5*X.band + 4*sin(2*pi*(X.band-0.5))
Yband.v.true <- 5 + 8*pi*cos(2*pi*(X.band - 0.5))
plot(X, out$Yhat, type = 'l',
ylim = c(min(out$scc[,1,2])-1,max(out$scc[,2,2])+1))
lines(X.band, Yband.true, col = 2)
lines(X.band, out$scc[,1,2], col='blue')
lines(X.band, out$scc[,2,2], col='blue')
plot(X.band, Yband.v.true, type = 'l', ylim = c(min(out$scc.deriv[,1,2])-1,max(out$scc.deriv[,2,2])+1))
lines(X.band, out$scc.deriv[,1,2], col='blue')
lines(X.band, out$scc.deriv[,2,2], col='blue')
View(out)
out
library(FDASCC)
n <- 50
N <- 100
# N <- 2*n^(1/4)*log(n)
X <- seq(1/N,1,1/N)
X.band <- seq(1/(N-1), 1, 1/(N-1))
Y <- matrix(0,n,N)
mu.true <- 5*X + 4*sin(2*pi*(X-0.5))
psi1 <- -sqrt(2)*cos(2*pi*(X-0.5))
psi2 <- sqrt(2) * sin(4*pi*(X-0.5))
sig <- 0.1
lam1 <- 2
lam2 <- 1
xi1 <- rnorm(n, 0, sqrt(lam1))
xi2 <- rnorm(n, 0, sqrt(lam2))
for(i in 1:n){
# Y[i,]=10*sin(X)+(rnorm(N, 0, sig))
Y[i,] <- mu.true + xi1[i]*psi1 + xi2[i]*psi2 + (rnorm(N, 0, sig))
}
out <- scc.1D(Ya=Y,X=X,X.band=X.band)
plot(out)
View(out)
